-------------------------------------------------------------------------------
							PA 3 CHECK CHESS PROJECT
			TEAM CAPABLANCA: Andrei Toma, Alexandru Ilie, Silvia Dragan
-------------------------------------------------------------------------------

-------------------------------------------------------------------------------
							Compilation instructions
-------------------------------------------------------------------------------
To compile, we give the command 'make build' in terminal, then we used "xboard 
-fcp "make run" -debug" for testing and debugging.

-------------------------------------------------------------------------------
								Project structure:
-------------------------------------------------------------------------------

-------------------------------------------------------------------------------
								First stage:
-------------------------------------------------------------------------------

Class Piece:
	We have implemented the class Piece. The attributes of a piece are: color(
	black/white) and position(a pair for int, char, ex: e4).
	Besides a constructor that initializez the piece's color and initial 
	position, the piece class has two virtual methods: findPositions and 
	getName. The following classes extend the piece class and implement the 
	said virtual methods:

	PAWN: if the pawn is in the initial position, we put in the positions 
	vector two new positions: one row forward and two rows forward, if the path
	to these positions is clear. Otherwise, the possible positions are: one row 
	forward, and in diagonals if there is an opponent's piece there to capture. 
	The pawn DOES NOT MOVE over other pieces.
		The pawn can also be promoted to queen if it reaches the last row of 
	the table. The method promote to queen removes the pawn from the table and 
	puts a new queen in its place. 

	KNIGHT: implements findPositions method according to a knight's moves.

	ROOK: implements findPositions method according to a rook's moves.

	BISHOP: implements findPositions method according to a bishop's moves.

	QUEEN: implements findPositions method according to a queen's moves.

	KING: implements findPositions method according to a king's moves.

Class GameBoard:
	A GameBoard object has as atribute the chess table: a 9x9 matrix of pieces. 
	The mothod init resets the table then puts the pieces on the table in the 
	initial order while also initializing the two vectors received as 
	parameters: a vector of white's pieces and a vector of black's pieces.
	Method showboard displays the chess table.

In main:
	Important variables:
		-availablePos -> vector that stores all available positoins
		-theChosenOnes -> the pawns that are chosen to move (one for each 
		color, 0 for white; 1 for black).

Commands read from stdin:
	xboard: read protover and N from sdin, write "feature sigint=0", "feature
	san=0", "feature myname=\"Capablanca\"" to stdout; 

	new: Initialise the gameboard and the chose pawns for each color.

	force: Set the mode to 0.

	go: Call the computeNextMove function (explained below). If it returns -1 
	there are no available positions for the piece to move, so we resign. 
	Change the mode to 1.

	quit: interrupt the program.

	move: If we are in mode 1, call function updateOpponentPieces(explained 
	below) to update the gameboard according to the moves the opponent made. 
	Calculate the next move/resign. If we are in mode 0, just update the 
	opponent's pieces.


Helper functions:

computeNextMove:
	Calculates the pawn's possible move choices by calling the findPositions 
	function. If there are no positions available or the pawn is NULL we resign 
	From the positions vector we chose one randomly and write it to stdout and 
	check if we captured an opponent's piece. Delete the piece we captured. If 
	we reached the last row, call promoteToQueen function to promote the pawn 
	to a queen. Update the gameboard.

updateOpponentPieces
	Update the gameboard by moving the opponent's piece to the given position. 
	If the opponent capured a piece, remove it from the list. If the opponent's
	pawn reached the last row promote it to queen.

- Members responsibilities:
Each team member implemented 2 of the piece-extending classes. We colaborated 
on the main method and implementing the commands.


-------------------------------------------------------------------------------
								Second stage:
-------------------------------------------------------------------------------

	Additions made to stage 1:

	In the second stage all the pieces will be available to be moved, not
only one black and white pawn. The moves will be chosen randomly and they will
be available moves. Also, we implemented the special moves: king side castle,
queen side castle, en passant and now the pawn can be promoted to any piece
(queen, knight, bishop, rook). 

	Computation of the available moves:

	The available moves will be computed with the help of the 
computePositions function. This function will iterate through the pieces of
the current color turn and generate all the possible position for every piece
with the findPositions function from the Piece class. After this, all the
moves generated for a piece will be checked if they are availble moves and if
the move is a valid move it will be added to a vector with the available
positions. After the move is checked, the move that was done in the tryMove
function will be removed with the removeMove function and the table will be back
in its initial state. If any of the castles can be done it will be prioritized
over another moves. Otherwise, if an en passant can be done it will be 
prioritized. Otherwise, en passant or any castle can't be done a random move
will be chosen.

	Checking if the move is valid:

	To check if a move is valid we used the tryMove function. In this function
the move given as parameter will be "fictionally" done to check if it is valid.
After, the move is done all moves of the pieces from the opponent color will be
generated. For every move will be checked if the king is in check and also if
the castles can be done (king not passing through check or king not already in
check).

	En passant:

	To check if the en passant move can be done we will use one more field in
the Pawn class (movedTwo). This field will be true when the pawn makes its first
move moving two position forward. If the opponent has a pawn near our pawn and
the opponent has the movedTwo field on true the en passant move will be added
to the vector of possible moves.

	Castles (queen side and king side):

	To check if one of the castles can be done we will use one more field in the
Rook and in the King class (hasMoved). For every kind of castle we will check
if the king didn't move, if the rook at its initial position, if the rook didn't
move until now and if there is no piece between the king and the rook that will
make the castle.

	Pawn promotion:

	Now a pawn can be upgraded to any other piece, not only the queen. Based on
the last character of the command the pawn will be upgraded to the following:
'b' - bishop, 'q' - queen, 'r' - rook, 'n' - knight. The new piece is created,
put on the gameboard, added to the vector with the pieces and the pawn that
was upgraded is erased from the vector. The upgrade that will be done is chosen
randomly.